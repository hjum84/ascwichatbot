<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>{{ program_display_name }} Chatbot</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
  <!-- Optional: Include marked.js if you are using Markdown formatting -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    .program-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      background-color: #f8f8f8;
      border-bottom: 1px solid #ddd;
      margin-bottom: 10px;
    }
    
    .program-title {
      font-size: 18px;
      font-weight: bold;
      color: #0073b1;
    }
    
    .program-badge {
      margin-left: 10px;
      background-color: #0073b1;
      color: white;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: normal;
    }
    
    .switch-program-btn {
      background-color: #0073b1;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    .switch-program-btn:hover {
      background-color: #005f87;
    }

    .mic-btn {
      background: #fff;
      border: none;
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: box-shadow 0.2s, background 0.2s;
      margin-right: 8px;
      cursor: pointer;
      outline: none;
      position: relative;
    }
    .mic-btn.active {
      background: #ff4d4f;
      box-shadow: 0 0 0 6px rgba(255,77,79,0.15);
    }
    .mic-btn svg {
      width: 28px;
      height: 28px;
      display: block;
    }
    .mic-btn .mic-wave {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(255,77,79,0.12);
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 0;
    }
    .mic-btn.active .mic-wave {
      opacity: 1;
      animation: mic-wave-pulse 1.2s infinite;
    }
    @keyframes mic-wave-pulse {
      0% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
      70% { transform: translate(-50%, -50%) scale(1.4); opacity: 0.2; }
      100% { transform: translate(-50%, -50%) scale(1.7); opacity: 0; }
    }
  </style>
</head>
<body>
  {% with messages = get_flashed_messages(with_categories=true) %}
      {% if messages %}
          <div style="padding: 10px; margin-bottom: 10px; border-radius: 5px; text-align: center; max-width: 800px; margin-left:auto; margin-right:auto; position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 100;">
          {% for category, message in messages %}
              <div class="alert alert-{{ category if category else 'info' }}" style="background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; padding: .75rem 1.25rem; margin-bottom: 5px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">{{ message }}</div>
          {% endfor %}
          </div>
      {% endif %}
  {% endwith %}

  <div class="chat-container">
    <div class="program-header">
      <div> <!-- Grouping div for left content -->
        <div class="program-title">
          {{ program_display_name }} Chatbot
          {% if program not in ['BCC', 'MI', 'Safety'] %}
          <span class="program-badge">CUSTOM</span>
          {% endif %}
        </div>
        {% if session.user_email %}
        <div class="user-status" style="font-size: 0.85em; color: #64748b; margin-top: 5px;">
            Logged in as: <strong>{{ session.user_email }}</strong> | 
            <a href="{{ url_for('logout') }}" style="color: #0073e6; text-decoration: none;">Logout</a>
        </div>
        {% endif %}
      </div>
      <a href="{{ url_for('switch_program') }}" class="switch-program-btn">Switch Program</a>
    </div>
    <div style="text-align:right; margin: 5px 10px 0 0;">
      <button id="clear-history-btn">Delete Conversation</button>
    </div>
    <div id="chat-box" class="chat-box">
      <div class="message bot system-welcome-message">
        <p>
          {{ intro_message }}
        </p>
      </div>
      {# Placeholder for chat history messages - will be populated by JS #}
      {% if chat_history %}
        {% for chat in chat_history %}
          <div class="message {{ chat.sender }}" data-sender="{{ chat.sender }}" data-raw='{{ chat.message|tojson|safe }}'></div>
        {% endfor %}
      {% endif %}
    </div>
    <div class="input-container">
      <textarea id="userInput" placeholder="Type your message here..." rows="1"></textarea>
      <button id="micBtn" class="mic-btn" type="button" aria-label="Start voice input">
        <span class="mic-wave"></span>
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M12 14c1.66 0 3-1.34 3-3V5a3 3 0 0 0-6 0v6c0 1.66 1.34 3 3 3zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V5z" fill="currentColor"/>
          <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z" fill="currentColor"/>
        </svg>
      </button>
      <button id="sendBtn" class="send-btn" aria-label="Send message">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
        </svg>
      </button>
    </div>
  </div>

  <script>
    // Auto-resize the textarea as the user types.
    var textarea = document.getElementById('userInput');
    textarea.addEventListener('input', function() {
      this.style.height = 'auto';                 // Reset height
      this.style.height = this.scrollHeight + 'px'; // Adjust height to content
    });

    // Allow sending the message when pressing Enter (unless Shift+Enter is used)
    document.getElementById('userInput').addEventListener("keydown", function(event) {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();  // Prevent newline insertion
        sendMessage();
      }
    });

    // Add click event to send button
    document.getElementById('sendBtn').addEventListener('click', sendMessage);

    // Typing animation function for bot messages
    function typeMessage(element, text, speed = 10) {
      return new Promise((resolve) => {
        let i = 0;
        element.classList.add('typing');
        
        function type() {
          if (i < text.length) {
            // Add character by character
            element.textContent += text.charAt(i);
            i++;
            setTimeout(type, speed);
          } else {
            element.classList.remove('typing');
            resolve();
          }
        }
        
        element.textContent = '';
        type();
      });
    }

    // Add the typing indicator
    function showTypingIndicator() {
      const chatBox = document.getElementById('chat-box');
      const typingDiv = document.createElement('div');
      typingDiv.className = 'typing-indicator';
      typingDiv.id = 'typing-indicator';
      typingDiv.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div>';
      chatBox.appendChild(typingDiv);
      chatBox.scrollTop = chatBox.scrollHeight;
      return typingDiv;
    }

    // Remove the typing indicator
    function removeTypingIndicator() {
      const typingIndicator = document.getElementById('typing-indicator');
      if (typingIndicator) {
        typingIndicator.remove();
      }
    }

    // Function to send the message to the backend
    function sendMessage() {
      const userInput = document.getElementById('userInput');
      const message = userInput.value;
      if (message.trim() === '') return; // Do nothing if the textarea is empty

      // Display the user's message in the chat
      addMessage(message, 'user');
      userInput.value = '';  // Clear the textarea
      userInput.style.height = 'auto';  // Reset height after clearing

      // Show typing indicator
      const typingIndicator = showTypingIndicator();

      // Send the message to the backend
      fetch('/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ message: message }),
      })
      .then(response => response.json())
      .then(data => {
        // Remove typing indicator after a slight delay to simulate thinking
        setTimeout(() => {
          removeTypingIndicator();
          if (data.reply) {
            addMessage(data.reply, 'bot', true);
          } else {
            addMessage("Error: " + data.error, 'bot', true);
          }
        }, 500 + Math.random() * 1000); // Random delay between 500ms and 1.5s
      })
      .catch(error => {
        removeTypingIndicator();
        addMessage("Network error: " + error, 'bot', true);
      });
    }

    // Function to add a message to the chat box
    function addMessage(message, sender, animate = false) {
      const chatBox = document.getElementById('chat-box');
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('message', sender);
      
      // Process the message for Markdown formatting and newline conversion
      const formattedMessage = marked.parseInline ? marked.parseInline(message).replace(/\n/g, '<br>') : message.replace(/\n/g, '<br>');
      
      if (sender === 'bot' && animate) {
        // Create a span for the text that will be animated
        const textSpan = document.createElement('span');
        textSpan.className = 'bot-text';
        messageDiv.innerHTML = `<p></p>`;
        messageDiv.querySelector('p').appendChild(textSpan);
        chatBox.appendChild(messageDiv);
        chatBox.scrollTop = chatBox.scrollHeight;
        
        // Animate the text after adding to DOM
        typeMessage(textSpan, message, 5).then(() => {
          // Replace with fully formatted text after typing animation
          messageDiv.querySelector('p').innerHTML = formattedMessage;
        });
      } else {
        messageDiv.innerHTML = `<p>${formattedMessage}</p>`;
        chatBox.appendChild(messageDiv);
        chatBox.scrollTop = chatBox.scrollHeight;
      }
    }

    // On page load, render chat history with markdown
    window.onload = function() {
      const chatBox = document.getElementById('chat-box');
      const welcomeMessageDiv = chatBox.querySelector('.system-welcome-message'); // Get the welcome message div
      const historyDivs = chatBox.querySelectorAll('.message:not(.system-welcome-message)'); // Get only history messages
      
      const renderedHistoryMessages = [];
      historyDivs.forEach(function(div) {
        const sender = div.getAttribute('data-sender');
        const raw = JSON.parse(div.getAttribute('data-raw'));
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message', sender);
        const formattedMessage = marked.parseInline ? marked.parseInline(raw).replace(/\n/g, '<br>') : raw.replace(/\n/g, '<br>');
        messageDiv.innerHTML = `<p>${formattedMessage}</p>`;
        renderedHistoryMessages.push(messageDiv);
        div.remove(); // Remove the raw data div
      });

      // Append rendered history messages after the welcome message
      renderedHistoryMessages.forEach(div => chatBox.appendChild(div));
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    // Delete conversation history button
    document.getElementById('clear-history-btn').onclick = function() {
      if (!confirm('Are you sure you want to delete all conversation history?')) return;
      fetch('/clear_chat_history', {method: 'POST'})
        .then(res => res.json())
        .then(data => {
          if(data.success) {
            // Clear only messages, not the welcome message
            const chatBox = document.getElementById('chat-box');
            const messagesToClear = chatBox.querySelectorAll('.message:not(.system-welcome-message)');
            messagesToClear.forEach(msg => msg.remove());
            // Optionally, you might want to add a message like "History cleared" or leave it empty
          } else {
            alert('Failed to delete conversation: ' + (data.error || 'Unknown error'));
          }
        })
        .catch(() => alert('Deletion failed due to a network error.'));
    }

    function replaceSpokenPunctuation(text) {
      return text
        .replace(/\s*\bperiod\b\s*/gi, ". ")
        .replace(/\s*\bcomma\b\s*/gi, ", ")
        .replace(/\s*\bexclamation (point|mark)\b\s*/gi, "! ")
        .replace(/\s*\bquestion mark\b\s*/gi, "? ")
        .replace(/\s*\bcolon\b\s*/gi, ": ")
        .replace(/\s*\bsemicolon\b\s*/gi, "; ")
        .replace(/\s*\bdash\b\s*/gi, "-")
        .replace(/\s*\bopen parenthesis\b\s*/gi, " (")
        .replace(/\s*\bclose parenthesis\b\s*/gi, ") ");
    }

    function autoCapitalizeSentences(text) {
      // Capitalize the first letter of the text and after punctuation
      return text.replace(/(^\s*\w|[.!?]\s*\w)/g, function(match) {
        return match.toUpperCase();
      });
    }

    let recognition;
    let recognizing = false;
    const micBtn = document.getElementById('micBtn');
    const userInput = document.getElementById('userInput');
    let appendedTranscript = "";

    // Always keep appendedTranscript in sync with textarea, even while mic is on
    userInput.addEventListener('input', function() {
      appendedTranscript = userInput.value;
    });

    if ('webkitSpeechRecognition' in window) {
      recognition = new webkitSpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US';

      recognition.onresult = function(event) {
        let interim_transcript = '';
        let final_transcript = '';
        for (let i = event.resultIndex; i < event.results.length; ++i) {
          if (event.results[i].isFinal) {
            final_transcript += event.results[i][0].transcript;
          } else {
            interim_transcript += event.results[i][0].transcript;
          }
        }
        // Replace spoken punctuation and auto-capitalize
        if (final_transcript) {
          final_transcript = replaceSpokenPunctuation(final_transcript);
          final_transcript = autoCapitalizeSentences(final_transcript);
          appendedTranscript += final_transcript;
        }
        if (interim_transcript) {
          interim_transcript = replaceSpokenPunctuation(interim_transcript);
          interim_transcript = autoCapitalizeSentences(interim_transcript);
        }
        userInput.value = appendedTranscript + interim_transcript;
        userInput.style.height = 'auto';
        userInput.style.height = userInput.scrollHeight + 'px';
      };

      recognition.onend = function() {
        recognizing = false;
        micBtn.classList.remove('active');
        appendedTranscript = userInput.value;
        userInput.style.height = 'auto';
        userInput.style.height = userInput.scrollHeight + 'px';
      };
    }

    micBtn.onclick = function() {
      if (!('webkitSpeechRecognition' in window)) return;
      if (recognizing) {
        recognition.stop();
        recognizing = false;
        micBtn.classList.remove('active');
      } else {
        appendedTranscript = userInput.value;
        recognition.start();
        recognizing = true;
        micBtn.classList.add('active');
      }
    };

    // Hide mic button if speech recognition is not supported
    if (!('webkitSpeechRecognition' in window)) {
      micBtn.style.display = 'none';
    }
  </script>
</body>
</html>
