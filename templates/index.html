<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>{{ program_display_name }} Chatbot</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
  <!-- Include marked.js for Markdown formatting (non-optional) -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Include DOMPurify for sanitizing HTML -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>
  <style>
    .program-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      background-color: #f8f8f8;
      border-bottom: 1px solid #ddd;
      margin-bottom: 10px;
    }
    
    .program-title {
      font-size: 18px;
      font-weight: bold;
      color: #0073b1;
    }
    
    .program-badge {
      margin-left: 10px;
      background-color: #0073b1;
      color: white;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: normal;
    }
    
    .switch-program-btn {
      background-color: #0073b1;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    .switch-program-btn:hover {
      background-color: #005f87;
    }

    .mic-btn {
      background: #fff;
      border: none;
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: box-shadow 0.2s, background 0.2s;
      margin-right: 8px;
      cursor: pointer;
      outline: none;
      position: relative;
    }
    .mic-btn.active {
      background: #ff4d4f;
      box-shadow: 0 0 0 6px rgba(255,77,79,0.15);
    }
    .mic-btn svg {
      width: 28px;
      height: 28px;
      display: block;
    }
    .mic-btn .mic-wave {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(255,77,79,0.12);
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 0;
    }
    .mic-btn.active .mic-wave {
      opacity: 1;
      animation: mic-wave-pulse 1.2s infinite;
    }
    @keyframes mic-wave-pulse {
      0% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
      70% { transform: translate(-50%, -50%) scale(1.4); opacity: 0.2; }
      100% { transform: translate(-50%, -50%) scale(1.7); opacity: 0; }
    }
  </style>
</head>
<body>
  {% with messages = get_flashed_messages(with_categories=true) %}
      {% if messages %}
          <div style="padding: 10px; margin-bottom: 10px; border-radius: 5px; text-align: center; max-width: 800px; margin-left:auto; margin-right:auto; position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 100;">
          {% for category, message in messages %}
              <div class="alert alert-{{ category if category else 'info' }}" style="background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; padding: .75rem 1.25rem; margin-bottom: 5px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">{{ message }}</div>
          {% endfor %}
          </div>
      {% endif %}
  {% endwith %}

  <div class="chat-container">
    <div class="modern-header">
      <div class="title-line">
        <h1 class="program-main-title">{{ program_display_name }} Chatbot</h1>
      </div>
      <div class="user-info-and-actions">
        {% if session.user_email %}
        <div class="user-status-modern">
          Logged in as: <strong>{{ session.user_email }}</strong>
          <span>|</span>
          <a href="{{ url_for('logout') }}" class="logout-link-modern">Logout</a>
        </div>
        {% endif %}
        <div class="header-actions-modern">
          <a href="{{ url_for('switch_program') }}" class="header-button-modern switch-program-modern">Switch Program</a>
          <button id="clear-history-btn" class="header-button-modern danger-modern">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" width="16" height="16">
              <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
            </svg>
            Delete Conversation
          </button>
        </div>
      </div>
    </div>
    <div id="chat-box" class="chat-box">
      <div class="message bot system-welcome-message">
        <p id="intro-message" data-content='{{ intro_message|tojson|safe }}'></p>
      </div>
      {# Placeholder for chat history messages - will be populated by JS #}
      {% if chat_history %}
        {% for chat in chat_history %}
          <div class="message {{ chat.sender }}" data-sender="{{ chat.sender }}" data-raw='{{ chat.message|tojson|safe }}'></div>
        {% endfor %}
      {% endif %}
    </div>
    <div class="input-area-container">
        <div class="attachment-bar" id="attachmentBar">
            <button class="attach-btn" aria-label="Attach file"><i class="bi bi-paperclip"></i></button>
            <button class="attach-btn" aria-label="Use camera"><i class="bi bi-camera"></i></button>
            <button class="attach-btn" aria-label="Record audio"><i class="bi bi-mic-fill"></i></button>
        </div>
        <div class="input-container" id="inputContainer">
          <button class="toggle-attach-bar-btn" id="toggleAttachBarBtn" aria-label="Toggle attachments">
              <i class="bi bi-plus-circle-fill"></i>
          </button>
          <textarea id="userInput" placeholder="Type your message..." rows="1"></textarea>
          <button id="micBtn" class="mic-btn" type="button" aria-label="Start voice input">
            <span class="mic-wave"></span>
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M12 14c1.66 0 3-1.34 3-3V5a3 3 0 0 0-6 0v6c0 1.66 1.34 3 3 3zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V5z" fill="currentColor"/>
              <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z" fill="currentColor"/>
            </svg>
          </button>
          <button id="sendBtn" class="send-btn" aria-label="Send message">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
            </svg>
          </button>
        </div>
    </div>
  </div>

  <script>
    const chatBox = document.getElementById('chat-box');
    const userInput = document.getElementById('userInput');
    const inputContainer = document.getElementById('inputContainer');
    const attachmentBar = document.getElementById('attachmentBar');
    const toggleAttachBarBtn = document.getElementById('toggleAttachBarBtn');
    let isAttachmentBarVisible = false;

    function scrollToBottom() {
        // A short delay can sometimes help ensure the layout has settled
        setTimeout(() => {
            chatBox.scrollTop = chatBox.scrollHeight;
        }, 50);
    }

    // Auto-resize the textarea as the user types.
    userInput.addEventListener('input', function() {
      recognitionBase = this.value; // Sync base with current input on user edit
      recognitionFinal = ""; // Reset accumulated transcript on manual edit
      this.style.height = 'auto';
      this.style.height = this.scrollHeight + 'px';
      scrollToBottom();
    });

    userInput.addEventListener('focus', () => {
        if (isAttachmentBarVisible) {
            attachmentBar.style.display = 'none';
            toggleAttachBarBtn.innerHTML = '<i class="bi bi-plus-circle-fill"></i>';
            isAttachmentBarVisible = false;
        }
        // Adjust view for keyboard
        // On some mobile browsers, focusing an input scrolls the page.
        // We might need to counter-scroll or adjust padding.
        setTimeout(() => { // Timeout to allow keyboard to show
            document.body.scrollTop = document.body.scrollHeight;
            scrollToBottom();
        }, 300);
    });

    toggleAttachBarBtn.addEventListener('click', () => {
        isAttachmentBarVisible = !isAttachmentBarVisible;
        if (isAttachmentBarVisible) {
            attachmentBar.style.display = 'flex';
            toggleAttachBarBtn.innerHTML = '<i class="bi bi-x-circle-fill"></i>'; // Change to close icon
            userInput.blur(); // Unfocus textarea
        } else {
            attachmentBar.style.display = 'none';
            toggleAttachBarBtn.innerHTML = '<i class="bi bi-plus-circle-fill"></i>'; // Change back to plus icon
        }
        scrollToBottom(); // Ensure chat is visible
    });

    // Allow sending the message when pressing Enter (unless Shift+Enter is used)
    userInput.addEventListener("keydown", function(event) {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    });

    document.getElementById('sendBtn').addEventListener('click', sendMessage);

    function typeMessage(element, text, speed = 10) {
      return new Promise((resolve) => {
        let i = 0;
        element.classList.add('typing');
        function type() {
          if (i < text.length) {
            element.textContent += text.charAt(i);
            i++;
            setTimeout(type, speed);
            scrollToBottom(); // Scroll as message types
          } else {
            element.classList.remove('typing');
            
            // After typing is complete, process any Markdown
            if (typeof marked !== 'undefined') {
                // Store the raw text before parsing
                const rawText = element.textContent;
                // Parse the Markdown and apply it
                const parsedContent = marked.parse(rawText);
                element.innerHTML = typeof DOMPurify !== 'undefined' ? 
                                  DOMPurify.sanitize(parsedContent) : 
                                  parsedContent;
            }
            
            resolve();
          }
        }
        element.textContent = '';
        type();
      });
    }

    function showTypingIndicator() {
      const typingDiv = document.createElement('div');
      typingDiv.className = 'typing-indicator';
      typingDiv.id = 'typing-indicator';
      typingDiv.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div>';
      chatBox.appendChild(typingDiv);
      scrollToBottom();
      return typingDiv;
    }

    function removeTypingIndicator() {
      const typingIndicator = document.getElementById('typing-indicator');
      if (typingIndicator) {
        typingIndicator.remove();
      }
    }

    function addMessage(text, sender, isHTML = true) {
        const messageDiv = document.createElement('div');
        // 여러 클래스 지원: sender가 공백 포함 문자열이면 분리해서 각각 class로 추가
        if (Array.isArray(sender)) {
            messageDiv.classList.add('message');
            sender.forEach(cls => messageDiv.classList.add(cls));
        } else if (typeof sender === 'string' && sender.includes(' ')) {
            messageDiv.classList.add('message');
            sender.split(' ').forEach(cls => messageDiv.classList.add(cls));
        } else {
            messageDiv.classList.add('message', sender);
        }
        const p = document.createElement('p');
        if (isHTML) {
            if (typeof marked !== 'undefined') {
                const parsedContent = marked.parse(text);
                p.innerHTML = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(parsedContent) : parsedContent;
            } else {
                p.textContent = text;
            }
        } else {
            p.textContent = text;
        }
        messageDiv.appendChild(p);
        chatBox.appendChild(messageDiv);
        scrollToBottom();
        return p; // Return the paragraph element for typing animation
    }

    function sendMessage() {
      const message = userInput.value;
      if (message.trim() === '') return;
      addMessage(message, 'user');
      userInput.value = '';
      userInput.style.height = 'auto';
      const typingIndicator = showTypingIndicator();
      fetch('/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ message: message }),
      })
      .then(response => response.json())
      .then(data => {
        setTimeout(() => {
          removeTypingIndicator();
          const botMessageP = addMessage("", 'bot', true); // Add as HTML, initially empty
          typeMessage(botMessageP, data.reply || "Sorry, I couldn't process that.").then(() => {
              scrollToBottom(); // Final scroll after typing is complete
          });
        }, 500); // Delay for bot "thinking"
      })
      .catch(error => {
        console.error('Error:', error);
        removeTypingIndicator();
        addMessage('Error: Could not connect to the server.', 'bot');
      });
    }
    
    // Initial scroll to bottom and rendering of existing messages
    document.addEventListener('DOMContentLoaded', () => {
        // Process intro message with Markdown
        const introMessageElement = document.getElementById('intro-message');
        const introContent = introMessageElement.getAttribute('data-content');
        if (typeof marked !== 'undefined') {
            introMessageElement.innerHTML = DOMPurify.sanitize(marked.parse(introContent));
        } else {
            introMessageElement.textContent = introContent;
        }

        // Process existing chat messages
        const existingMessages = chatBox.querySelectorAll('.message[data-raw]');
        existingMessages.forEach(msgDiv => {
            const rawMessage = JSON.parse(msgDiv.getAttribute('data-raw'));
            const sender = msgDiv.getAttribute('data-sender');
            const p = document.createElement('p');
            if (typeof marked !== 'undefined') {
                p.innerHTML = DOMPurify.sanitize(marked.parse(rawMessage));
            } else {
                p.textContent = rawMessage;
            }
            msgDiv.appendChild(p);
            msgDiv.removeAttribute('data-raw'); // Clean up
        });
        scrollToBottom();
    });

    // Handle potential viewport changes when virtual keyboard shows/hides on mobile
    if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', () => {
            // This gives the height of the visual viewport (excluding keyboard)
            // We can adjust the chatBox height or scroll based on this.
            // For example, ensure the input is visible:
            inputContainer.scrollIntoView({ behavior: 'smooth', block: 'end' });
            scrollToBottom();
        });
    }

    // Clear history button
    document.getElementById('clear-history-btn').addEventListener('click', function() {
        if (confirm("Are you sure you want to delete this conversation history? This action cannot be undone.")) {
            fetch("{{ url_for('clear_chat_history') }}", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ program: '{{ program }}'}) // Send current program
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    chatBox.innerHTML = ''; // Clear visually
                    // Re-add welcome message with Markdown processing
                    const welcomeMessage = '{{ intro_message|safe }}';
                    addMessage(welcomeMessage, 'bot system-welcome-message', true);
                    alert("Conversation history cleared.");
                } else {
                    alert("Error clearing history: " + data.error);
                }
            })
            .catch(error => {
                console.error('Error clearing history:', error);
                alert("Error clearing history.");
            });
        }
    });

    // Speech Recognition setup
    const micBtn = document.getElementById("micBtn");
    let recognition = null;
    let isListening = false;
    let recognitionBase = ""; // The input value when speech recognition starts
    let recognitionFinal = ""; // Accumulated final transcript

    function replaceSpokenPunctuation(text) {
      return text
        .replace(/\s*\bperiod\b\s*/gi, ". ")
        .replace(/\s*\bcomma\b\s*/gi, ", ")
        .replace(/\s*\bexclamation (point|mark)\b\s*/gi, "! ")
        .replace(/\s*\bquestion mark\b\s*/gi, "? ")
        .replace(/\s*\bcolon\b\s*/gi, ": ")
        .replace(/\s*\bsemicolon\b\s*/gi, "; ")
        .replace(/\s*\bdash\b\s*/gi, "-")
        .replace(/\s*\bopen parenthesis\b\s*/gi, " (")
        .replace(/\s*\bclose parenthesis\b\s*/gi, ") ");
    }

    function autoCapitalizeSentences(text) {
      // Capitalize the first letter of the text and after punctuation
      return text.replace(/(^\s*\w|[.!?]\s*\w)/g, function(match) {
        return match.toUpperCase();
      });
    }

    // Check if browser supports Speech Recognition
    if ("webkitSpeechRecognition" in window || "SpeechRecognition" in window) {
        // Initialize speech recognition
        recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        recognition.continuous = true;  // Changed to true to keep recording
        recognition.interimResults = true;
        recognition.lang = "en-US"; // Set language (English)

        // Handle results
        recognition.onresult = function(event) {
            let interimTranscript = "";
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    recognitionFinal += event.results[i][0].transcript;
                } else {
                    interimTranscript += event.results[i][0].transcript;
                }
            }
            // Process transcripts
            let finalText = autoCapitalizeSentences(replaceSpokenPunctuation(recognitionFinal));
            let interimText = autoCapitalizeSentences(replaceSpokenPunctuation(interimTranscript));
            userInput.value = recognitionBase + finalText + interimText;
            userInput.style.height = "auto";
            userInput.style.height = userInput.scrollHeight + "px";
        };

        // Handle end of speech recognition
        recognition.onend = function() {
            // Only save transcript if we're actually stopping (not just pausing)
            if (!isListening) {
                if (userInput.value) {
                    recognitionFinal = userInput.value;
                }
                micBtn.classList.remove("active");
            } else {
                // If we're still supposed to be listening, restart recognition
                try {
                    recognition.start();
                } catch (error) {
                    console.error("Error restarting recognition:", error);
                }
            }
        };

        // Handle errors
        recognition.onerror = function(event) {
            console.error("Speech recognition error:", event.error);
            isListening = false;
            micBtn.classList.remove("active");
            if (event.error === "not-allowed") {
                alert("Microphone access is required. Please allow microphone access in your browser settings.");
            }
        };

        // Toggle speech recognition on button click
        micBtn.addEventListener("click", function() {
            if (isListening) {
                recognition.stop();
                isListening = false;
                micBtn.classList.remove("active");
            } else {
                try {
                    recognitionBase = userInput.value; // Save input value at recognition start
                    recognitionFinal = "";
                    recognition.start();
                    isListening = true;
                    micBtn.classList.add("active");
                    userInput.focus();
                } catch (error) {
                    console.error("Speech recognition error:", error);
                    alert("Could not start speech recognition. Please check your browser settings.");
                }
            }
        });
        
        // Track last click time for double-click detection
        let lastClickTime = 0;
    } else {
        // Browser does not support speech recognition
        micBtn.addEventListener("click", function() {
            alert("This browser does not support speech recognition. Please use Chrome or Edge browser.");
        });
        console.warn("Speech Recognition not supported in this browser");
    }
  </script>
</body>
</html>
